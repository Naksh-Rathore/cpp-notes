# Functions

Declaring a function:

```cpp
returntype functionName(arguments) {
    body
}
```
Pretty simple, don't want to complicated this. Same as C, Java, and many others.

Calling a function:

```cpp
functionName(arguments);
```

# Scope

A local variable is a variable defined in a function (yes, that includes `main()`). Same as C so I don't want to overcomplicate.
Just remember that all variables defined in a function get put out of scope (they essentially *die*) when the function ends (the last curly bracket `}`)

## Temporary Objects

A temporary object (also sometimes called an anonymous object) is an unnamed object that is used to hold a value that is only needed for a short period of time. Temporary objects are generated by the compiler when they are needed.

There are many different ways that temporary values can be created, but here’s a common one:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored?

	return 0;
}
```
# Intro to Namespaces

## The global namespace

In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of an **implicitly-defined namespace called the global namespace** (sometimes also called the global scope).

We discuss the global namespace in more detail in lesson 7.4 -- Introduction to global variables.

For now, there are two things you should know:

* Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.
* Although variables can be defined in the global namespace, this should **generally be avoided** (we discuss why in lesson 7.8 -- Why (non-const) global variables are evil).

Example:

```cpp
#include <iostream> // imports the declaration of std::cout into the global scope

// All of the following statements are part of the global namespace

void foo();    // okay: function forward declaration
int x;         // compiles but strongly discouraged: non-const global variable definition (without initializer)
int y { 5 };   // compiles but strongly discouraged: non-const global variable definition (with initializer)
x = 5;         // compile error: executable statements are not allowed in namespaces

int main()     // okay: function definition
{
    return 0;
}

void goo();    // okay: A function forward declaration
```

## std

When C++ was originally designed, all of the identifiers in the C++ standard library (including `std::cin` and `std::cout`) were available to be used without the `std::` prefix (they were part of the global namespace). However, this meant that any identifier in the standard library could potentially conflict with any name you picked for your own identifiers (also defined in the global namespace). Code that was once working might suddenly have a naming conflict when you include a different part of the standard library. Or worse, code that compiled under one version of C++ might not compile under the next version of C++, as new identifiers introduced into the standard library could have a naming conflict with already written code. So C++ moved all of the functionality in the standard library into a namespace named std (short for “standard”).

It turns out that std::cout‘s name isn’t really std::cout. It’s actually just cout, and std is the name of the namespace that identifier cout is part of. Because cout is defined in the std namespace, the name cout won’t conflict with any objects or functions named cout that we create outside of the std namespace (such as in the global namespace).

# Header Files

C++ code files (with a `.cpp` extension) are not the only files commonly seen in C++ programs. The other type of file is called a header file. Header files usually have a `.h` extension, but you will occasionally see them with a `.hpp` extension or no extension at all.

Conventionally, header files are used to propagate a bunch of related forward declarations into a code file.

## Header Guards

A header guard is used to to allow duplicate definitions to be resolved properly.

Here is the slightly **unsafe** version of a header file:

```cpp
void myFunction();
int myVariable;
```


```cpp
#ifndef FILE_NAME_H
#define FILE_NAME_H

void myFunction();
int myVariable;

#endif
```

Notice the difference? the `#ifendf`, `#define`, and `#endif` allow the function to have duplicate definitions.
